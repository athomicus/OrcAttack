-- Player State Machine States
local STATE_IDLE = 1                    -- Player is standing still
local STATE_WALKING = 2                 -- Player is walking to clicked position
local STATE_WALKING_FOR_STONE = 3       -- Player is walking to pick up stone
local STATE_HOLDING_STONE = 4           -- Player is holding a stone
local STATE_THROWING_STONE = 5          -- Player is walking to throw stone

-- Initialize player state and cache stone pile positions
function init(self)
    --print("Player initialization")

    -- Enable input handling for this game object
    msg.post('.', "acquire_input_focus")

    -- Set initial state
    self.state = STATE_IDLE

    -- Stone tracking (nil when not holding a stone)
    self.stone_id = nil

    -- Cache stone pile positions for collision detection
    self.stone_pos_left = go.get_position("/stones_left")
    self.stone_pos_right = go.get_position("/stones_right")
    self.stone_size = vmath.vector3(100, 300, 0)  -- Bounding box: 100px wide, 300px tall
end

-- Handle player input (touch/click)
function on_input(self, action_id, action)
    -- Only process when touch is released (tap complete)
    if action_id == hash("touch") and action.released then
        local tap_position = vmath.vector3(action.x, action.y, 0)

        -- CASE 1: If holding stone, any tap triggers throw
        if self.state == STATE_HOLDING_STONE then
            self.state = STATE_THROWING_STONE
            throw_stone(self, action.x)
            return
        end

        -- Check if player clicked on stone pile (left or right)
        local stone_clicked = is_stone_collider_clicked(tap_position, self.stone_pos_left, self.stone_size) or
                              is_stone_collider_clicked(tap_position, self.stone_pos_right, self.stone_size)

        -- CASE 2: Clicked on stone pile - walk to it and pick it up
        if stone_clicked and (self.state == STATE_IDLE or self.state == STATE_WALKING) then
           -- print("Clicked on stone pile")
            self.state = STATE_WALKING_FOR_STONE
            move_to(self, action.x)

        -- CASE 3: Clicked on empty area - just walk there
        elseif self.state == STATE_IDLE or self.state == STATE_WALKING then
            self.state = STATE_WALKING
            move_to(self, action.x)
        end
    end
end

-- Called every frame (optional debug)
function update(self, dt)
    -- Uncomment to debug current state
    -- pprint(self.state)
end

-- Handle messages sent to this game object
function on_message(self, message_id, message, sender)
    -- Set player sprite to run left (flip horizontally)
    if message_id == hash("set_animation_left") then
        msg.post("#sprite", "play_animation", {id = hash("Run")})
        sprite.set_hflip("#sprite", true)  -- Flip sprite horizontally

    -- Set player sprite to run right (normal direction)
    elseif message_id == hash("set_animation_right") then
        msg.post("#sprite", "play_animation", {id = hash("Run")})
        sprite.set_hflip("#sprite", false)  -- No flip
    end
end

-- Move player to target X position
-- Determines direction, animates sprite, and handles state on arrival
function move_to(self, new_x)
    local speed = 300  -- Movement speed in pixels per second
    local duration = calculate_animation_duration(new_x, speed)

    -- Determine direction and flip sprite accordingly
    if new_x < go.get_position().x then
        msg.post(".", "set_animation_left")  -- Moving left (sprite flipped horizontally)
    else
        msg.post(".", "set_animation_right")  -- Moving right (sprite flipped horizontally)
    end

    -- Animate player movement along X axis
    go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, new_x, go.EASING_LINEAR, duration, 0,
        function()
            -- On arrival: check if we should grab stone
            if not self.stone_id and self.state == STATE_WALKING_FOR_STONE then
               -- print("Picking up stone")
                grab_stone(self)
            else
                -- Otherwise return to idle
                self.state = STATE_IDLE
                msg.post("#sprite", "play_animation", {id = hash("throw")})
            end
        end
    )
end

-- Create and attach stone to player
function grab_stone(self)
    -- Create stone slightly above player position
    local player_pos = go.get_position() + vmath.vector3(0, 50, 0)

    -- Spawn stone from factory (scale 2x)
    self.stone_id = factory.create("#stone_factory", player_pos, nil, nil, 2)

    -- Update state
    self.state = STATE_HOLDING_STONE

    -- Parent stone to player so it follows player movement
    go.set_parent(self.stone_id, go.get_id())

    -- Set stone's local position relative to player
    go.set_position(vmath.vector3(0, 10, 0), self.stone_id)

    --print("Stone picked up:", self.stone_id)

    -- Play throw animation
    msg.post("#sprite", "play_animation", {id = hash("throw")})
end

-- Walk to throw position and release stone
function throw_stone(self, new_x)
    -- Safety check: ensure we're actually holding a stone
    if not self.stone_id then
        self.state = STATE_IDLE
        return
    end

    -- Determine direction and flip sprite accordingly
    if new_x < go.get_position().x then
        msg.post(".", "set_animation_left")  -- Moving left
    else
        msg.post(".", "set_animation_right")  -- Moving right
    end

    local speed = 300  -- Movement speed in pixels per second
    local duration = calculate_animation_duration(new_x, speed)

   -- print("Throwing stone:", self.stone_id)

    -- Animate player to throw position
    go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, new_x, go.EASING_LINEAR, duration, 0,
        function()
            -- On arrival: release stone at player's position
            local new_stone_pos = go.get_position()

            -- Unparent stone from player (make it independent)
            go.set_parent(self.stone_id, nil)

            -- Set stone position in world coordinates
            new_stone_pos.z = 0  -- Ensure correct depth layer

            go.set_position(new_stone_pos, self.stone_id)

            -- Tell stone to start falling
              msg.post(self.stone_id, "stone_start_falling")
            --print(self.stone_id.." FALL")

            -- Clear stone reference and return to idle
            self.stone_id = nil
            self.state = STATE_IDLE

            -- Play throw animation
            msg.post("#sprite", "play_animation", {id = hash("throw")})
        end
    )
end

-- Check if a click position is inside stone pile bounding box
-- Uses simple AABB (Axis-Aligned Bounding Box) collision detection
function is_stone_collider_clicked(click_pos, stone_pos, stone_size)
    local half_width = stone_size.x * 0.5
    local half_height = stone_size.y * 0.5

    -- Return true if click is within bounding box
    return click_pos.x >= stone_pos.x - half_width and
           click_pos.x <= stone_pos.x + half_width and
           click_pos.y >= stone_pos.y - half_height and
           click_pos.y <= stone_pos.y + half_height
end

-- Calculate how long animation should take based on distance
-- Also cancels any existing animations to allow retargeting mid-walk
function calculate_animation_duration(new_x, speed)
    -- Cancel current movement animation (allows changing direction mid-walk)
    go.cancel_animations(".")

    -- Calculate distance to target
    local pos = go.get_position()
    local distance = math.abs(new_x - pos.x)

    -- Duration = distance / speed (time = distance / velocity)
    local duration = distance / speed
    return duration
end