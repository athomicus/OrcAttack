go.property("target_point", vmath.vector3()) --majac property mozemy przekazac punkt docelowy przy tworzeniu orka z factory
go.property("index_ladder", 0) -- index punktu docelowego w module.lua by zwolnic go po smierci orka
local module = require('main.module')
-- property declared so factory.create(..., { target_point = point }) will set it on the new instance
 
local STATE_WALK_TO_POSITION = 1       
local STATE_CLIMBING = 2               
local STATE_ATTACK_WALL = 3
local STATE_FALL = 4      
local STATE_DIE = 5  
local CLIMB_POS_Y = 620  
 
function init(self)
	--print("[ORC] Orc target:", self.target_point.x, self.target_point.y)

	self.touched_ladder_id = nil
	self.state = STATE_WALK_TO_POSITION
	self.scale = go.get("#sprite", "scale")
	self.speed = 100 --pixels per second speed of orc walking
	self.climb_speed = 80
	self.playback_rate = 1.0 -- walking animation speed multiplier
	self.falling_speed = 0

 	go.set("#sprite_fade", "tint.w", 0.0) -- Ustaw przezroczystość drugiego sprite'a na 0 to do crossfade animacji przy climb	
	go.set("#sprite_attack", "tint.w", 0.0) -- Ustaw przezroczystość trzeciego sprite'a na 0 to do crossfade animacji przy climb	
	go.set("#sprite_death", "tint.w", 0.0)
	--pprint("Orc initialized at point index: ".. tostring(index))


--#######################################  Orc Animate(walk) to position
	sprite.play_flipbook("#sprite", hash("walking"), nil, { playback_rate = self.playback_rate }) -- speed up walking animation 
	local start_pos = go.get_position()
	local distance = math.abs(self.target_point.x - start_pos.x)
	
	local duration = distance / self.speed
	
	if self.target_point.x > start_pos.x then
		sprite.set_hflip("#sprite",true) -- Odbicie poziome w zależności od kierunku ruchu
	end
	--go.animate(url, property, playback, to, easing, duration, delay, complete_function)
	local delay = math.random()*0.3
	go.animate('.', 'position.x', go.PLAYBACK_ONCE_FORWARD, self.target_point.x, go.EASING_LINEAR, duration,delay,function ()		
		--pprint("Reached:".. tostring(index))

--####################################### Orc Climb animation 		
		 
			switch_to_climbing(self)
		 
	end)	
	 	
end

function switch_to_climbing(self)	
	--self.scale = self.scale  
 	  -- Crossfade: current OUT + target IN
    
	go.animate("#sprite", "tint.w", go.PLAYBACK_ONCE_FORWARD, 0.0, go.EASING_INOUTQUAD, 0.2, 0.0)
    go.animate("#sprite_fade", "tint.w", go.PLAYBACK_ONCE_FORWARD, 1.0, go.EASING_INOUTQUAD, 0.2, 0.0)
	sprite.play_flipbook("#sprite_fade", "walkToClimb",
	function(self,message_id,message,sender)
		--self.scale = vmath.vector3(1)
		
		sprite.play_flipbook("#sprite","climbing")
		go.set("#sprite", "tint.w", 1.0)
		go.set("#sprite","scale", vmath.vector3(0.55))
		go.set("#sprite_fade", "tint.w", 0.0)
		if(self.state ~= STATE_DIE ) then
			self.state = STATE_CLIMBING
		end
	end)

end

function update(self, dt)
	
	if self.state == STATE_CLIMBING then
		--print(self.current_trigger_ladder_id_for_orc)
		msg.post(self.touched_ladder_id, "enable_ladder") -- wyslij wiadomosc do drabiny by sioe wlaczyla
		local pos = go.get_position()
		pos.y = pos.y + self.climb_speed* dt
		go.set_position(pos)
		
		if pos.y >60 and pos.y < 80 then
			--ledder
		end
---############################################ ATACK WALL
		if pos.y >= CLIMB_POS_Y then
			self.state = STATE_ATTACK_WALL
			 -- Crossfade: current OUT + target IN
    		go.animate("#sprite", "tint.w", go.PLAYBACK_ONCE_FORWARD, 0.0, go.EASING_INOUTQUAD, 0.2, 0.0)
			go.animate("#sprite_fade", "tint.w", go.PLAYBACK_ONCE_FORWARD, 0.0, go.EASING_INOUTQUAD, 0.2, 0.0)
    		go.animate("#sprite_attack", "tint.w", go.PLAYBACK_ONCE_FORWARD, 1.0, go.EASING_INOUTQUAD, 0.25, 0.0)
			
		end
	end
--############################################ DIE
	if self.state == STATE_DIE then
		--orc umarl nic nie robi
		
		local pos = go.get_position()
		pos.y = pos.y - self.falling_speed * dt
		go.set_position(pos)
		if pos.y <=-20 then go.delete(go.get_id(), true) 	end
	end
	if self.state == STATE_ATTACK_WALL then
		
		
	end
	
end

function on_message(self, message_id, message, sender)
	-- fallback: receive target via message if set by factory caller using msg.post
	if message_id == hash("set_target") then
		if message.target_point then
			self.target_point = message.target_point
		end
		return
	end



	--##### ORC DOSTAL KAMIENIEM PRZELACZ GO NA DIE 


		if message_id == hash("orc_hitted_by_stone") then
				--pprint("[ORC]Orc hit by stone - DIE")
				self.state = STATE_DIE
				self.falling_speed = message.stone_speed
				 
				sprite.play_flipbook("#sprite_death", "death",nil,{playback_rate = self.playback_rate })
				--go.set("#collisionobject", "enabled", false)  -- wylacz dla Orca by nie kolidowal z innymi obiektamAMI W SZCZEGOLNOSci Z kamieniem
				msg.post("#collisionobject", "disable")
				
				go.set("#sprite_death", "tint.w", 1.0)
				go.set("#sprite_fade", "tint.w", 0.0)
				go.set("#sprite_attack", "tint.w", 0.0)
				go.set("#sprite", "tint.w", 0.0)

				module.free_ladder_for_next_orc(self.index_ladder) -- zwolnij punkt w module.lua by inny orc mogl z niego skorzystac
			
			 	
			 
			end
		
		
		if message_id == hash("trigger_response") then				
			if message.enter and message.other_group==hash("ladder") then   				
				self.touched_ladder_id = message.other_id 
				-- w message.other_id jest id drabiny z ktora sie zderzyl orc np. "/ladder2"						
			end		
			
		end

	end
 

