go.property("target_point", vmath.vector3()) --majac property mozemy przekazac punkt docelowy przy tworzeniu orka z factory
local module = require('main.module')
-- property declared so factory.create(..., { target_point = point }) will set it on the new instance
 
local STATE_WALK_TO_POSITION = 1       
local STATE_CLIMBING = 2               
local STATE_ATTACK_WALL = 3
local STATE_FALL = 4      
local STATE_DIE = 5  
local CLIMB_POS_Y = 620  
 
function init(self)
	--print("[ORC] Orc target:", self.target_point.x, self.target_point.y)

	self.current_trigger_ladder_id_for_orc = nil
	self.state = STATE_WALK_TO_POSITION
	self.scale = go.get("#sprite", "scale")
	self.speed = 100 --pixels per second speed of orc walking
	self.climb_speed = 80
	self.playback_rate = 1.0 -- walking animation speed multiplier
	self.falling_speed = 0
--####################################### Find free place to that Orc can walk
--	local index, point = module.get_free_point() --{ pos = vmath.vector3(60, 75, 0), taken = false }, -- Point 1
--	module.set_taken(index, true)
--	 if index == nil then
		--pprint("No free point [DELETE] Orc")
--	    go.delete() -- No free point, delete the Orc
--		return
--	end
	-- read the property value (set by factory.create) into instance state
	-- `target_point` is the property declared above; if not set, default to a zero vector
		--self.target_point = go.get(".", "target_point") 

--print(target_points)
 	go.set("#sprite_fade", "tint.w", 0.0) -- Ustaw przezroczystość drugiego sprite'a na 0 to do crossfade animacji przy climb	
	go.set("#sprite_attack", "tint.w", 0.0) -- Ustaw przezroczystość trzeciego sprite'a na 0 to do crossfade animacji przy climb	
	go.set("#sprite_death", "tint.w", 0.0)
	--pprint("Orc initialized at point index: ".. tostring(index))


--#######################################  Orc Animate(walk) to position
	sprite.play_flipbook("#sprite", hash("walking"), nil, { playback_rate = self.playback_rate }) -- speed up walking animation 
	local start_pos = go.get_position()
	local distance = math.abs(self.target_point.x - start_pos.x)
	
	local duration = distance / self.speed
	
	if self.target_point.x > start_pos.x then
		sprite.set_hflip("#sprite",true) -- Odbicie poziome w zależności od kierunku ruchu
	end
	--go.animate(url, property, playback, to, easing, duration, delay, complete_function)
	local delay = math.random()*0.3
	go.animate('.', 'position.x', go.PLAYBACK_ONCE_FORWARD, self.target_point.x, go.EASING_LINEAR, duration,delay,function ()		
		--pprint("Reached:".. tostring(index))

--####################################### Orc Climb animation 		
		 
			switch_to_climbing(self)
		 
	end)	
	 	
end

function switch_to_climbing(self)	
	--self.scale = self.scale  
 	  -- Crossfade: current OUT + target IN
    
	go.animate("#sprite", "tint.w", go.PLAYBACK_ONCE_FORWARD, 0.0, go.EASING_INOUTQUAD, 0.2, 0.0)
    go.animate("#sprite_fade", "tint.w", go.PLAYBACK_ONCE_FORWARD, 1.0, go.EASING_INOUTQUAD, 0.2, 0.0)
	sprite.play_flipbook("#sprite_fade", "walkToClimb",
	function(self,message_id,message,sender)
		--self.scale = vmath.vector3(1)
		
		sprite.play_flipbook("#sprite","climbing")
		go.set("#sprite", "tint.w", 1.0)
		go.set("#sprite","scale", vmath.vector3(0.55))
		go.set("#sprite_fade", "tint.w", 0.0)
		if(self.state ~= STATE_DIE ) then
			self.state = STATE_CLIMBING
		end
	end)

end

function update(self, dt)
	
	if self.state == STATE_CLIMBING then
		--print(self.current_trigger_ladder_id_for_orc)
		msg.post(self.current_trigger_ladder_id_for_orc, "enable_ladder") -- wyslij wiadomosc do drabiny by sioe wlaczyla
		local pos = go.get_position()
		pos.y = pos.y + self.climb_speed* dt
		go.set_position(pos)
		
		if pos.y >60 and pos.y < 80 then
			--ledder
		end
---############################################ ATACK WALL
		if pos.y >= CLIMB_POS_Y then
			self.state = STATE_ATTACK_WALL
			 -- Crossfade: current OUT + target IN
    		go.animate("#sprite", "tint.w", go.PLAYBACK_ONCE_FORWARD, 0.0, go.EASING_INOUTQUAD, 0.2, 0.0)
			go.animate("#sprite_fade", "tint.w", go.PLAYBACK_ONCE_FORWARD, 0.0, go.EASING_INOUTQUAD, 0.2, 0.0)
    		go.animate("#sprite_attack", "tint.w", go.PLAYBACK_ONCE_FORWARD, 1.0, go.EASING_INOUTQUAD, 0.25, 0.0)
			--go.set("#sprite", "tint.w", 0.0)
			--go.set("#sprite_fade", "tint.w", 0.0)
			--go.set("#sprite_attack", "tint.w", 1.0)
		--	sprite.play_flipbook("#sprite_attack", "attack")
			--sprite.play_flipbook("#sprite", "attackWall")
		end
	end
--############################################ DIE
	if self.state == STATE_DIE then
		--orc umarl nic nie robi
		
		local pos = go.get_position()
		pos.y = pos.y - self.falling_speed * dt
		go.set_position(pos)
		if pos.y <=-20 then go.delete(go.get_id(), true) 	end
	end
	if self.state == STATE_ATTACK_WALL then
		
		
	end
	--local velocity = go.get("#", "velocity") -- Twój sposób na pobranie prędkości lub innej zmiennej
	--sprite.set_hflip("#sprite",true) -- Odbicie poziome w zależności od kierunku ruchu
end

function on_message(self, message_id, message, sender)
	-- fallback: receive target via message if set by factory caller using msg.post
	if message_id == hash("set_target") then
		if message.target_point then
			self.target_point = message.target_point
		end
		return
	end



	--##### ORC DOSTAL KAMIENIEM PRZELACZ GO NA DIE 


		if message_id == hash("orc_hitted_by_stone") then
				--pprint("[ORC]Orc hit by stone - DIE")
				self.state = STATE_DIE
				self.falling_speed = message.stone_speed
				 
				sprite.play_flipbook("#sprite_death", "death",nil,{playback_rate = self.playback_rate })
				--go.set("#collisionobject", "enabled", false)  -- wylacz dla Orca by nie kolidowal z innymi obiektamAMI W SZCZEGOLNOSci Z kamieniem
				msg.post("#collisionobject", "disable")
				
				go.set("#sprite_death", "tint.w", 1.0)
				go.set("#sprite_fade", "tint.w", 0.0)
				go.set("#sprite_attack", "tint.w", 0.0)
				go.set("#sprite", "tint.w", 0.0)
				--go.set("#sprite_death", "tint.w", 1.0)
				
				--przewbudowac skrypt by ORC dostawal jeszcze gdzie ma isc nr punktu i jesli
				-- nie doszedl to tez trzeba zwolnic punkt 
				--obecnie jest jak dotknie drabiny to punkt zwalnia na false
				module.set_free(self.current_trigger_ladder_id_for_orc)
			 	
			 
			end
		
		
		if message_id == hash("trigger_response") then			
		--	print("Ladder trigger collision detected")
			--print("TRIGGER:", message.enter, "group:", message.other_group)

			
			--wiadomosc z triggera wysylana jest automatczycnie true-wejscie , false wyjscie	
			-- jesli meeasge.enter == true to wejscie do triggera
			if message.enter and message.other_group==hash("ladder") then
   				
				--wejscie do triggera
				local current_ladder_id = message.other_id
				keep_last_trigger_touchedby_orc(self, current_ladder_id)
			else
				
				keep_last_trigger_touchedby_orc(self, nil)	
			end		
			
		end

	end
 

function keep_last_trigger_touchedby_orc(self, ladder_id)
	if ladder_id  then
		self.current_trigger_ladder_id_for_orc = ladder_id
	--print("Ladder"..ladder_id.." touched by Orc")
	return
	end
	

--trzeba sprawdzic czy Orc opuscil Triger drabiny jak tak to czekac na nowy triger 
--zapisac go doa jakiejs zmiennej lub tablicy i ostatni na ktorym zostal  wziasc jako current

end
--1 Spawn
--2 idz do punktu
--3 crossfade animacji
--4 wspinaj sie i wyciagaj drabine