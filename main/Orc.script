
local module = require('main.module')
local STATE_WALK_TO_POSITION = 1       
local STATE_CLIMBING = 2               
local STATE_ATTACK_WALL = 3
local STATE_FALL = 4      
local STATE_DIE = 5  
 
function init(self)
	
	self.current_trigger_ladder_id_for_orc = nil
	self.state = STATE_WALK_TO_POSITION
	self.scale = go.get("#sprite", "scale")

--####################################### Find free place to that Orc can walk
	local index, point = module.get_free_point() --{ pos = vmath.vector3(60, 75, 0), taken = false }, -- Point 1
	module.set_taken(index, true)
	 if index == nil then
		pprint("No free point [DELETE] Orc")
	    go.delete() -- No free point, delete the Orc
		return
	end
	go.set("#sprite_fade", "tint.w", 0.0) -- Ustaw przezroczystość drugiego sprite'a na 0 to do crossfade animacji przy climb	
	go.set("#sprite_attack", "tint.w", 0.0) -- Ustaw przezroczystość trzeciego sprite'a na 0 to do crossfade animacji przy climb	
	pprint("Orc initialized at point index: ".. tostring(index))


--#######################################  Orc Animate(walk) to position
	local start_pos = go.get_position()
	local distance = math.abs(point.x - start_pos.x)
	local speed = 50 -- pixels per second
	local duration = distance / speed
	
	if point.x > start_pos.x then
		sprite.set_hflip("#sprite",true) -- Odbicie poziome w zależności od kierunku ruchu
	end
	--go.animate(url, property, playback, to, easing, duration, delay, complete_function)
	local delay = math.random()*0.3
	go.animate('.', 'position.x', go.PLAYBACK_ONCE_FORWARD, point.x, go.EASING_LINEAR, duration,delay,function ()		
		--pprint("Reached:".. tostring(index))

--####################################### Orc Climb animation 		
		switch_to_climbing(self)
		
	end)	
	 	
end

function switch_to_climbing(self)	
	self.scale = self.scale  
 	  -- Crossfade: current OUT + target IN
    go.animate("#sprite", "tint.w", go.PLAYBACK_ONCE_FORWARD, 0.0, go.EASING_INOUTQUAD, 0.2, 0.0)
    go.animate("#sprite_fade", "tint.w", go.PLAYBACK_ONCE_FORWARD, 1.0, go.EASING_INOUTQUAD, 0.2, 0.0)
	sprite.play_flipbook("#sprite_fade", "walkToClimb",
	function(self,message_id,message,sender)
		--self.scale = vmath.vector3(1)
		
		sprite.play_flipbook("#sprite","climbing")
		go.set("#sprite", "tint.w", 1.0)
		go.set("#sprite","scale", vmath.vector3(0.55))
		go.set("#sprite_fade", "tint.w", 0.0)
		self.state = STATE_CLIMBING
	end)

end

function update(self, dt)
	
	if self.state == STATE_CLIMBING then
		--print(self.current_trigger_ladder_id_for_orc)
		msg.post(self.current_trigger_ladder_id_for_orc, "enable_ladder") -- wyslij wiadomosc do drabiny by sioe wlaczyla
		local pos = go.get_position()
		pos.y = pos.y + 40 * dt
		go.set_position(pos)
		
		if pos.y >60 and pos.y < 80 then
			--ledder
		end

		if pos.y >= 640 then
			self.state = STATE_ATTACK_WALL
			 -- Crossfade: current OUT + target IN
    		go.animate("#sprite", "tint.w", go.PLAYBACK_ONCE_FORWARD, 0.0, go.EASING_INOUTQUAD, 0.2, 0.0)
			go.animate("#sprite_fade", "tint.w", go.PLAYBACK_ONCE_FORWARD, 0.0, go.EASING_INOUTQUAD, 0.2, 0.0)
    		go.animate("#sprite_attack", "tint.w", go.PLAYBACK_ONCE_FORWARD, 1.0, go.EASING_INOUTQUAD, 0.25, 0.0)
			--go.set("#sprite", "tint.w", 0.0)
			--go.set("#sprite_fade", "tint.w", 0.0)
			--go.set("#sprite_attack", "tint.w", 1.0)
		--	sprite.play_flipbook("#sprite_attack", "attack")
			--sprite.play_flipbook("#sprite", "attackWall")
		end
	end
	
	if self.state == STATE_ATTACK_WALL then
		
		
	end
	--local velocity = go.get("#", "velocity") -- Twój sposób na pobranie prędkości lub innej zmiennej
	--sprite.set_hflip("#sprite",true) -- Odbicie poziome w zależności od kierunku ruchu
end

function on_message(self, message_id, message, sender)

		--pprint("Ladder trigger message received")
		if message_id == hash("trigger_response") then			
		--	print("Ladder trigger collision detected")
			--print("TRIGGER:", message.enter, "group:", message.other_group)


			--wiadomosc z triggera wysylana jest automatczycnie true-wejscie , false wyjscie	
			-- jesli meeasge.enter == true to wejscie do triggera
			if message.enter and message.other_group==hash("ladder") then
   				
				--wejscie do triggera
				local current_ladder_id = message.other_id
				keep_last_trigger_touchedby_orc(self, current_ladder_id)
			else
				
				keep_last_trigger_touchedby_orc(self, nil)	
			end		
			
		end

	end
 

function keep_last_trigger_touchedby_orc(self, ladder_id)
	if ladder_id  then
		self.current_trigger_ladder_id_for_orc = ladder_id
	--print("Ladder"..ladder_id.." touched by Orc")
	return
	end
	

--trzeba sprawdzic czy Orc opuscil Triger drabiny jak tak to czekac na nowy triger 
--zapisac go doa jakiejs zmiennej lub tablicy i ostatni na ktorym zostal  wziasc jako current

end
--1 Spawn
--2 idz do punktu
--3 crossfade animacji
--4 wspinaj sie i wyciagaj drabine